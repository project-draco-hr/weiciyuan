{
  if (!mEnabled)   return false;
  final int action=ev.getAction() & MotionEventCompat.ACTION_MASK;
  if (DEBUG)   if (action == MotionEvent.ACTION_DOWN)   Log.v(TAG,"Received ACTION_DOWN");
  if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP || (action != MotionEvent.ACTION_DOWN && mIsUnableToDrag)) {
    endDrag();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_MOVE:
    final int activePointerId=mActivePointerId;
  if (activePointerId == INVALID_POINTER)   break;
final int pointerIndex=this.getPointerIndex(ev,activePointerId);
final float x=MotionEventCompat.getX(ev,pointerIndex);
final float dx=x - mLastMotionX;
final float xDiff=Math.abs(dx);
final float y=MotionEventCompat.getY(ev,pointerIndex);
final float yDiff=Math.abs(y - mLastMotionY);
if (DEBUG) Log.v(TAG,"onInterceptTouch moved to:(" + x + ", "+ y+ "), diff:("+ xDiff+ ", "+ yDiff+ "), mLastMotionX:"+ mLastMotionX);
if (xDiff > mTouchSlop && xDiff > yDiff && thisSlideAllowed(dx)) {
if (DEBUG) Log.v(TAG,"Starting drag! from onInterceptTouch");
startDrag();
mLastMotionX=x;
setScrollingCacheEnabled(true);
}
 else if (yDiff > mTouchSlop) {
mIsUnableToDrag=true;
}
break;
case MotionEvent.ACTION_DOWN:
mActivePointerId=ev.getAction() & ((Build.VERSION.SDK_INT >= 8) ? MotionEvent.ACTION_POINTER_INDEX_MASK : MotionEvent.ACTION_POINTER_INDEX_MASK);
mLastMotionX=mInitialMotionX=MotionEventCompat.getX(ev,mActivePointerId);
mLastMotionY=MotionEventCompat.getY(ev,mActivePointerId);
if (thisTouchAllowed(ev)) {
mIsBeingDragged=false;
mIsUnableToDrag=false;
if (isMenuOpen() && mViewBehind.menuTouchInQuickReturn(mContent,mCurItem,ev.getX() + mScrollX)) {
mQuickReturn=true;
}
}
 else {
mIsUnableToDrag=true;
}
break;
case MotionEventCompat.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
if (!mIsBeingDragged) {
if (mVelocityTracker == null) {
mVelocityTracker=VelocityTracker.obtain();
}
mVelocityTracker.addMovement(ev);
}
return mIsBeingDragged || mQuickReturn;
}
