{
  if (!mEnabled)   return false;
  if (!mIsBeingDragged && !thisTouchAllowed(ev))   return false;
  final int action=ev.getAction();
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action & MotionEventCompat.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    completeScroll();
  mLastMotionX=mInitialMotionX=ev.getX();
mActivePointerId=MotionEventCompat.getPointerId(ev,0);
break;
case MotionEvent.ACTION_MOVE:
if (!mIsBeingDragged) {
if (mActivePointerId == INVALID_POINTER) break;
final int pointerIndex=getPointerIndex(ev,mActivePointerId);
final float x=MotionEventCompat.getX(ev,pointerIndex);
final float dx=x - mLastMotionX;
final float xDiff=Math.abs(dx);
final float y=MotionEventCompat.getY(ev,pointerIndex);
final float yDiff=Math.abs(y - mLastMotionY);
if (DEBUG) Log.v(TAG,"onTouch moved to:(" + x + ", "+ y+ "), diff:("+ xDiff+ ", "+ yDiff+ ")\nmIsBeingDragged:"+ mIsBeingDragged+ ", mLastMotionX:"+ mLastMotionX);
if ((xDiff > mTouchSlop || (mQuickReturn && xDiff > mTouchSlop / 4)) && xDiff > yDiff && thisSlideAllowed(dx)) {
if (DEBUG) Log.v(TAG,"Starting drag! from onTouch");
startDrag();
mLastMotionX=x;
setScrollingCacheEnabled(true);
}
 else {
if (DEBUG) Log.v(TAG,"onTouch returning false");
return false;
}
}
if (mIsBeingDragged) {
final int activePointerIndex=getPointerIndex(ev,mActivePointerId);
if (mActivePointerId == INVALID_POINTER) {
break;
}
final float x=MotionEventCompat.getX(ev,activePointerIndex);
final float deltaX=mLastMotionX - x;
mLastMotionX=x;
float oldScrollX=getScrollX();
float scrollX=oldScrollX + deltaX;
final float leftBound=getLeftBound();
final float rightBound=getRightBound();
if (scrollX < leftBound) {
scrollX=leftBound;
}
 else if (scrollX > rightBound) {
scrollX=rightBound;
}
mLastMotionX+=scrollX - (int)scrollX;
scrollTo((int)scrollX,getScrollY());
pageScrolled((int)scrollX);
}
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)VelocityTrackerCompat.getXVelocity(velocityTracker,mActivePointerId);
final int scrollX=getScrollX();
final float pageOffset=(float)(scrollX - getDestScrollX(mCurItem)) / getBehindWidth();
final int activePointerIndex=getPointerIndex(ev,mActivePointerId);
if (mActivePointerId != INVALID_POINTER) {
final float x=MotionEventCompat.getX(ev,activePointerIndex);
final int totalDelta=(int)(x - mInitialMotionX);
int nextPage=determineTargetPage(pageOffset,initialVelocity,totalDelta);
setCurrentItemInternal(nextPage,true,true,initialVelocity);
}
 else {
setCurrentItemInternal(mCurItem,true,true,initialVelocity);
}
mActivePointerId=INVALID_POINTER;
endDrag();
}
 else if (mQuickReturn && mViewBehind.menuTouchInQuickReturn(mContent,mCurItem,ev.getX() + mScrollX)) {
setCurrentItem(1);
endDrag();
}
break;
case MotionEvent.ACTION_CANCEL:
if (mIsBeingDragged) {
setCurrentItemInternal(mCurItem,true,true);
mActivePointerId=INVALID_POINTER;
endDrag();
}
break;
case MotionEventCompat.ACTION_POINTER_DOWN:
{
final int index=MotionEventCompat.getActionIndex(ev);
final float x=MotionEventCompat.getX(ev,index);
mLastMotionX=x;
mActivePointerId=MotionEventCompat.getPointerId(ev,index);
break;
}
case MotionEventCompat.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
int pointerIndex=this.getPointerIndex(ev,mActivePointerId);
if (mActivePointerId == INVALID_POINTER) break;
mLastMotionX=MotionEventCompat.getX(ev,pointerIndex);
break;
}
return true;
}
